#!/usr/bin/env python3
import itertools
import os
import sys
import tempfile
from pathlib import Path
from subprocess import run as command

# -------------------------------------------------------------------------------------------------|

# Constants
INSTALL_MAX_ATTEMPTS = 3
TEMP_DIR = Path(tempfile.gettempdir())

# --user no longer works, thanks
os.environ["PIP_BREAK_SYSTEM_PACKAGES"] = "1"

# Write annoying __pycache__ and .pyc on temporary directory, keeps development directories clean.
# On Linux, it's under /tmp - System RAM, brutally fast, also shouldn't take that much memory
os.environ["PYTHONPYCACHEPREFIX"] = str(TEMP_DIR/"__pycache__")

# Weird KDE wallet or GNOME wallet askings on Linux
if os.name == "posix":
    os.environ["PYTHON_KEYRING_BACKEND"] = "keyring.backends.null.Keyring"

# -------------------------------------------------------------------------------------------------|

# Binaries convenience
PYTHON = sys.executable
POETRY = [PYTHON, "-m", "poetry"]
PIP    = [PYTHON, "-m", "pip"]

# Path to this script
BRAKEIT = Path(__file__).absolute()

# Change directory to where the script is from anywhere
os.chdir(BRAKEIT.parent)

# Make the script executable (runnable if on PATH)
if os.name in ["posix", "mac"]:
    os.chmod(BRAKEIT, 0o755)

# -------------------------------------------------------------------------------------------------|

# Ensure pip is installed
for attempt in itertools.count(0):
    try:
        import pip
        break
    except Exception:
        if attempt == INSTALL_MAX_ATTEMPTS:
            print("Failed to install pip automatically")
            exit(1)
        print("Couldn't import pip")

    # Fixme: Do we need a more complex solution?
    print("Installing pip with [python -m ensurepip]")
    command([sys.executable, "-m", "ensurepip", "--upgrade"])

# -------------------------------------------------------------------------------------------------|

# Install poetry
for attempt in itertools.count(0):

    # Couldn't install poetry or not available on Path
    if attempt == INSTALL_MAX_ATTEMPTS:
        print(f"Attempted {INSTALL_MAX_ATTEMPTS} times to install poetry, but failed")
        print(f"1) Try restarting the shell, maybe it was installed and PATH wasn't updated")
        print( "2) Installe it manually at (https://python-poetry.org/docs/#installation)")
        exit(1)

    # Call poetry --version, command might exit status 1 if it's not installed
    status = command(POETRY + ["--version"], capture_output=True)

    # Poetry is installed, break
    if status.returncode == 0:
        break

    # Install poetry and try again
    command(PIP + ["install", "--user", "poetry"])

# Create, install dependencies on virtual environment
command(POETRY + ["install"])

# -------------------------------------------------------------------------------------------------|

# # Hot patch Poetry to allow for expanduser and symlinks on path dependencies
# Note: This shouldn't break this repo, as relative paths are used, is a fix for private infra

# Find the virtual environment path
venv_path = Path(command(POETRY + ["env", "info", "-p"], capture_output=True).stdout.decode().strip())

# Find and patch the file, fail safe
if (path_dependency := next(venv_path.glob("**/*/path_dependency.py"))):
    path_dependency.write_text(
        path_dependency.read_text().replace(
            "self._path = path\n",
            "self._path = (path := path.expanduser())\n"
        )
    )

# -------------------------------------------------------------------------------------------------|

# Bonus: Symlink the venv path to the current directory
# Do that on the installer script as `poetry env info -p` is slow
# Note: This is not a crucial step
try:
    # Remove previous symlink if exists
    if (dot_venv := BRAKEIT.parent/".venvs").exists():
        dot_venv.unlink()

    # Actually symlink .venvs -> Poetry venvs directory
    dot_venv.symlink_to(venv_path.parent)

except Exception:
    print("Couldn't symlink .venvs to the virtual environment path, skipping")

# Clear screen
try:
    if os.name == "nt":
        command("cls")
    else:
        command("clear")
except Exception:
    pass

# Install scripts, desktop files and submodules (+ignore private infra)
if os.environ.get("EXPERIMENTAL_SUBMODULES", None) == "1":
    command(POETRY + ["run", "broken", "submodules", "install"])
else:
    command(POETRY + ["run", "broken", "install"])

# Enter virtual environment
command(POETRY + ["shell"])
