#!/usr/bin/env python3
# | (c) Tremeschin, AGPLv3-only License | Protostar Project | #

import itertools
import os
import shutil
import subprocess
import sys as system
import tempfile
from contextlib import contextmanager
from enum import Enum
from functools import partial
from pathlib import Path

import requests

# ------------------------------------------------------------------------------------------------|

# Binaries shorthands
python = system.executable
pip = [python, "-m", "pip"]
rustup = "rustup"
cargo = "cargo"
upx = "upx"
sh = "sh"

# ------------------------------------------------------------------------------------------------|
# Install dependencies.

# Ensure pip
try: __import__("pip")
except ModuleNotFoundError:
    import ensurepip
    ensurepip.bootstrap()

same = lambda x: (x, x)
dependencies = [
    same("arrow"),
    same("datetime"),
    same("distro"),
    same("forbiddenfruit"),
    same("iteration_utilities"),
    same("loguru"),
    same("platform"),
    same("pygit2"),
    same("requests"),
    same("toml"),
    ("typer", "typer[all]"),
]

for importName, packageName in dependencies:
    while True:
        try:
            globals()[importName] = __import__(importName)
            break
        except ModuleNotFoundError:
            subprocess.run(pip + ["install", packageName, "--user"])

# ------------------------------------------------------------------------------------------------|

from iteration_utilities import deepflatten

# [[a, b], c, [d, e, f], [g, h]] -> [a, b, c, d, e, f, g, h]
flatten = lambda stuff: deepflatten(stuff, types=list)

# run(["binary", "-m"], "arg1", "arg2")
run = lambda *a, **k: subprocess.run(map(str, flatten(a)), **k)

# # Utility functions

def binaryExists(binary) -> bool:
    return shutil.which(binary) is not None

@contextmanager
def download(url) -> Path:
    with tempfile.NamedTemporaryFile() as temp:
        temp.write(requests.get(url).content)
        yield Path(temp.name)

# functools.partial doesn't support type hinting, so we convert
# a partial to a dummy function that have those
def callablePartial(f: partial, *a, **k):
    def call(): f(*a, **k)
    return call

# ------------------------------------------------------------------------------------------------|

ABOUT = """
Broken Source Software Manager script

(c) 2023 Tremeschin, AGPLv3-only License.
"""

class Nebula:
    ProjectsAndFeatures = {}

    def __init__(self) -> None:
        self.setupLog()

    # Builds CLI commands and starts Typer
    def cli(self) -> None:
        self.typerApp = typer.Typer(help=ABOUT, no_args_is_help=True)
        self.typerApp.command()(self.release)
        self.typerApp.command()(self.date)
        self.typerApp.command()(self.hints)
        self.typerApp.command()(self.releaseAll)

        # Directories
        self.Root     = Path(__file__).absolute().parent
        self.Releases = self.Root/"Releases"
        self.Build    = self.Releases/"Build"

        # Cargo dictionary
        self.cargotoml = toml.loads((self.Root/"Cargo.toml").read_text())

        # Add Typer commands for all projects
        for project in self.cargotoml["bin"]:
            projectName = project["name"]

            # Don't add non existing projects (private repos)
            if not (self.Root/project["path"]).exists(): continue

            # List of required features specified in Cargo.tml
            if len(features := project.get("required-features", [])) > 0:
                features = [["--features", f] for f in features]

            Nebula.ProjectsAndFeatures[projectName] = features

            # This is a bit sophisticated, projectName should be kept after the callable
            # is created, so we have a method that creates a method with given string
            def runProjectTemplate(projectName, features):
                def runProject(ctx: typer.Context):
                    run(cargo, "run", "--bin", projectName, features, "--", ctx.args)
                return runProject

            # Create Typer command
            self.typerApp.command(
                name=projectName.lower(),
                help=f"Project: {projectName}",

                # Catch extra (unknown to typer) arguments that are sent to Rust
                context_settings=dict(allow_extra_args=True, ignore_unknown_options=True),

                # Rust projects implement their own --help
                add_help_option=False,

            )(runProjectTemplate(projectName, features))

        # Execute the CLI
        self.typerApp()

    # Clone Protostar repository and submodules to current directory
    def gitCloneProtostar(self) -> None:
        self.info("Installing Rust")
        self.installRust()

        # Not the most pretty progress bar but it does the job
        class GitCloneProgress(pygit2.RemoteCallbacks):
            def transfer_progress(self, stats):
                print(f"\r:: Progress: ({stats.received_bytes} bytes) ({stats.indexed_objects}/{stats.total_objects} objects)", end='', flush=True)
                if stats.indexed_objects == stats.total_objects: print("\r", end='')

        self.info("Cloning Protostar repository..")
        protostarRepo = pygit2.clone_repository("https://github.com/BrokenSource/Protostar", "Protostar", callbacks=GitCloneProgress())
        os.chdir("Protostar")

        # Attempt to init and clone public submodules
        for submodule in protostarRepo.listall_submodules():
            try:
                protostarRepo.init_submodules([submodule])
                protostarRepo.update_submodules([submodule], callbacks=GitCloneProgress())
                self.info(f"Cloning submodule: [{submodule}]")

            # Ignore private submodules
            except Exception as error:
                if "authentication" not in str(error):
                    raise error

        self.info("Now type 'cd Protostar' and './nebula'")

    # Initiates self.* logging capabilities
    def setupLog(self) -> None:

        # Add milliseconds to timedelta for logging
        forbiddenfruit.curse(datetime.timedelta, "milliseconds", property(lambda self: f"{self.microseconds/1000:5.0f}"))

        # Set up empty logger
        loguru.logger.remove()
        self.logger = loguru.logger.bind()

        # Add stdout logging
        self.logger.add(system.stdout, colorize=True, level="TRACE",
            format=f"[<green>{{elapsed.milliseconds}}ms</green>]─[<level>{{level:7}}</level>]<level> ▸ {{message}}</level>")

        # self.* functions logging
        for logType in ["info", "warning", "error", "debug", "trace", "success", "critical"]:
            setattr(self, f"{logType}", getattr(self.logger, logType))

    # Rust stable toolchain
    def installRust(self) -> None:
        if not binaryExists("rustup"):
            self.info("Installing Rustup")
            run(sh, download("https://sh.rustup.rs"), "--profile", "default", "-y")
        if not all([binaryExists(b) for b in ["rustc", "cargo"]]):
            self.info("Installing Rust Stable Toolchain")
            run(rustup, "default", "stable")

    # # Commands section

    def hints(self):
        """Let Nebula find Quality of Life stuff you can add to your system"""

        # "$ ./nebula" -> "$ nebula"
        if not "." in os.environ.get("PATH").split(os.pathsep):
            self.info(f"You can append '.' to $PATH env var so current directory binaries are found, no more typing './nebula' but simply 'nebula'. Add to your shell config: 'export PATH=$PATH:.'")

    def date(self) -> None:
        """Set current UTC dates on Cargo.toml, returns date string"""
        date = arrow.utcnow().format("YYYY.M.D")
        return date

    def release(self, project: str, target: str, profile: str="ultra") -> None:
        """Compile and release a project to a target platform"""

        # Acronym for all available platforms
        if target == "all":
            for target in ["linux", "windows", "macos"]:
                try:
                    self.release(project, target)
                except NotImplementedError:
                    pass
            return

        date = self.date()

        # Distros IDs: https://distro.readthedocs.io/en/latest/
        linuxDistro = distro.id()
        host = platform.system().lower()

        # # Install Requirements depending on host platform
        if host == "linux":
            if target == "linux":
                pass

            # Windows compile pre-requisites
            elif target == "windows":
                if linuxDistro == "arch":
                    run("sudo pacman -Syu base-devel mingw-w64-toolchain upx --needed --noconfirm".split())
                elif id == "ubuntu":
                    run("sudo apt update")
                else:
                    self.error(f"Your Linux distro [{id}] is not listed for dependencies, continue anyway?")
                    if input(":: ").lower() not in ["y", "yes"]:
                        system.exit()

            elif target == "macos":
                raise NotImplementedError("macOS Releases not supported from Linux")

        elif host == "windows":
            raise NotImplementedError("Nebula releases on Windows not implemented")

        elif host == "macos":
            raise NotImplementedError("Nebula releases on macOS not implemented")

        # # Target platform
        if target == "linux":
            targetTriple  = "x86_64-unknown-linux-gnu"
            compileSuffix = ""
            releaseSuffix = ".bin"

        elif target == "windows":
            targetTriple  = "x86_64-pc-windows-gnu"
            compileSuffix = ".exe"
            releaseSuffix = ".exe"

        elif target == "macos":
            targetTriple  = "x86_64-apple-darwin"
            compileSuffix = ""
            releaseSuffix = ".bin"

        # Add target toolchain for Rust
        run(rustup, "target", "add", targetTriple)

        # Build the binary
        run(cargo, "build",
            "--bin", project,
            "--target", targetTriple,
            "--profile", profile,
            Nebula.ProjectsAndFeatures[project]
        )

        # Post-compile binary namings and release name
        compiledBinary   = self.Build/targetTriple/profile/f"{project}{compileSuffix}"
        releaseBinary    = self.Releases/f"{project.lower()}-{target}-{date}{releaseSuffix}"
        releaseBinaryUPX = releaseBinary.parent/(releaseBinary.stem + f"-upx{releaseSuffix}")

        # Default release and UPX
        shutil.copy(compiledBinary, releaseBinary)
        run(upx, "-q", "-9", "--lzma", releaseBinary, "-o", releaseBinaryUPX)

    def releaseAll(self):
        """Attempt release of all projects for all platforms, let it fail or not"""
        for project in Nebula.ProjectsAndFeatures.keys():
            for target in ["linux", "windows", "macos"]:
                try:
                    self.release(project, target)
                except Exception:
                    pass

# ------------------------------------------------------------------------------------------------|

if __name__ == "__main__":
    nebula = Nebula()

    # Running from a file or pipe?
    if system.stdin.isatty():
        nebula.cli()
    else:
        nebula.gitCloneProtostar()
