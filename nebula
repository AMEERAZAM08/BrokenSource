#!/usr/bin/env python3
# | (c) Tremeschin, AGPLv3-only License | Protostar Project | #

import itertools
import os
import shutil
import subprocess
import sys as system
import tempfile
from contextlib import contextmanager
from enum import Enum
from functools import partial
from pathlib import Path

import requests

# ------------------------------------------------------------------------------------------------|

# Binaries shorthands
python = system.executable
pip = [python, "-m", "pip"]
rustup = "rustup"
cargo = "cargo"
sh = "sh"

# ------------------------------------------------------------------------------------------------|
# Install dependencies.

# Ensure pip
try: __import__("pip")
except ModuleNotFoundError:
    import ensurepip
    ensurepip.bootstrap()

same = lambda x: (x, x)
dependencies = [
    ("typer", "typer[all]"),
    same("platform"),
    same("requests"),
    same("iteration_utilities"),
    same("loguru"),
    same("forbiddenfruit"),
    same("datetime"),
    same("arrow"),
    same("toml"),
    same("pygit2"),
]

for importName, packageName in dependencies:
    while True:
        try:
            globals()[importName] = __import__(importName)
            break
        except ModuleNotFoundError:
            subprocess.run(pip + ["install", packageName, "--user"])

# ------------------------------------------------------------------------------------------------|

from iteration_utilities import deepflatten

# [[a, b], c, [d, e, f], [g, h]] -> [a, b, c, d, e, f, g, h]
flatten = lambda stuff: deepflatten(stuff, types=list)

# run(["binary", "-m"], "arg1", "arg2")
run = lambda *a,**k: subprocess.run(map(str, flatten(a)), **k)

# # Utility functions

def binaryExists(binary) -> bool:
    return shutil.which(binary) is not None

@contextmanager
def download(url) -> Path:
    with tempfile.NamedTemporaryFile() as temp:
        temp.write(requests.get(url).content)
        yield Path(temp.name)

# functools.partial doesn't support type hinting, so we convert
# a partial to a dummy function that have those
def callablePartial(f: partial, *a, **k):
    def call(): f(*a, **k)
    return call

# ------------------------------------------------------------------------------------------------|

ABOUT = """
Broken Source Software Manager script

(c) 2023 Tremeschin, AGPLv3-only License.
"""

class Nebula:
    def __init__(self) -> None:
        self.setupLog()

    # Builds CLI commands and starts Typer
    def cli(self) -> None:
        self.typerApp = typer.Typer(help=ABOUT, no_args_is_help=True)
        self.typerApp.command()(self.compile)
        self.typerApp.command()(self.date)
        self.typerApp.command()(self.hints)
        self.installRust()

        # Directories
        self.Root     = Path(__file__).absolute().parent
        self.Releases = self.Root/"Releases"
        self.Build    = self.Releases/"Build"

        # Cargo dictionary
        self.cargotoml = toml.loads((self.Root/"Cargo.toml").read_text())

        # Add Typer commands for all projects
        for project in self.cargotoml["bin"]:
            projectName = project["name"]

            # List of required features specified in Cargo.tml
            if len(features := project.get("required-features", [])) > 0:
                features = [["--features", f] for f in features]

            # This is a bit sophisticated, projectName should be kept after the callable
            # is created, so we have a method that creates a method with given string
            def runProjectTemplate(projectName, features):
                def runProject(ctx: typer.Context):
                    run(cargo, "run", "--bin", projectName, features, "--", ctx.args)
                return runProject

            # Create Typer command
            self.typerApp.command(
                name=projectName.lower(),
                help=f"(AUTO) Runs project: {projectName}",

                # Catch extra (unknown to typer) arguments that are sent to Rust
                context_settings=dict(allow_extra_args=True, ignore_unknown_options=True),

                # Rust projects implement their own --help
                add_help_option=False,

            )(runProjectTemplate(projectName, features))

        # Execute the CLI
        self.typerApp()

    # Clone Protostar repository and submodules to current directory
    def gitCloneProtostar(self) -> None:

        # Not the most pretty progress bar but it does the job
        class GitCloneProgress(pygit2.RemoteCallbacks):
            def transfer_progress(self, stats):
                print(f"\r:: Progress: ({stats.received_bytes} bytes) ({stats.indexed_objects}/{stats.total_objects} objects)", end='', flush=True)
                if stats.indexed_objects == stats.total_objects: print("\r", end='')

        self.info("Cloning Protostar repository..")
        protostarRepo = pygit2.clone_repository("https://github.com/BrokenSource/Protostar", "Protostar", callbacks=GitCloneProgress())
        os.chdir("Protostar")

        # Attempt to init and clone public submodules
        for submodule in protostarRepo.listall_submodules():
            try:
                protostarRepo.init_submodules([submodule])
                protostarRepo.update_submodules([submodule], callbacks=GitCloneProgress())
                self.info(f"Cloning submodule: [{submodule}]")

            # Ignore private submodules
            except Exception as error:
                if "authentication" not in str(error):
                    raise error

        self.info("Now type 'cd Protostar' and './nebula'")

    # Initiates self.* logging capabilities
    def setupLog(self) -> None:

        # Add milliseconds to timedelta for logging
        forbiddenfruit.curse(datetime.timedelta, "milliseconds", property(lambda self: f"{self.microseconds/1000:5.0f}"))

        # Set up empty logger
        loguru.logger.remove()
        self.logger = loguru.logger.bind()

        # Add stdout logging
        self.logger.add(system.stdout, colorize=True, level="TRACE",
            format=f"[<green>{{elapsed.milliseconds}}ms</green>]─[<level>{{level:7}}</level>]<level> ▸ {{message}}</level>")

        # self.* functions logging
        for logType in ["info", "warning", "error", "debug", "trace", "success", "critical"]:
            setattr(self, f"{logType}", getattr(self.logger, logType))

    # Rust stable toolchain
    def installRust(self) -> None:
        if not binaryExists("rustup"):
            self.info("Installing Rustup")
            run(sh, download("https://sh.rustup.rs"), "--profile", "default", "-y")
        if not all([binaryExists(b) for b in ["rustc", "cargo"]]):
            self.info("Installing Rust Stable Toolchain")
            run(rustup, "default", "stable")

    # # Commands section

    def hints(self):
        """Let Nebula find Quality of Life stuff you can add to your system"""

        # "$ ./nebula" -> "$ nebula"
        if not "." in os.environ.get("PATH").split(os.pathsep):
            self.info(f"You can append '.' to $PATH env var so current directory binaries are found, no more typing './nebula' but simply 'nebula'. Add to your shell config: 'export PATH=$PATH:.'")

    def date(self) -> None:
        """Set current UTC dates on Cargo.toml"""
        date = arrow.utcnow().format("YYYY.M.D")
        print(date)

    def compile(self, project: str, target: str) -> None:
        """Compile a project to a target platform"""
        self.date()
        # run(cargo, project.value)

# ------------------------------------------------------------------------------------------------|

if __name__ == "__main__":
    nebula = Nebula()

    # Running from a file or pipe?
    if system.stdin.isatty():
        nebula.cli()
    else:
        nebula.gitCloneProtostar()

class Platform(Enum):
    Windows = "windows"
    Linux   = "linux"
    macOS   = "mac"
