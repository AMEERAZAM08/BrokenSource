#!/usr/bin/env python3
# | (c) Tremeschin, AGPLv3-only License | Protostar Project | #

# pyright: reportUndefinedVariable=false

import os
import shutil
import subprocess
import sys as system
import tempfile
from contextlib import contextmanager
from pathlib import Path

import requests

# ------------------------------------------------------------------------------------------------|
# Install dependencies.

# Ensure pip
try: __import__("pip")
except ModuleNotFoundError:
    try:
        import ensurepip
        ensurepip.bootstrap()
    except ModuleNotFoundError:
        with tempfile.NamedTemporaryFile() as getpip:
            getpip.write_bytes(requests.get("https://bootstrap.pypa.io/get-pip.py").content)
            subprocess.run([system.executable, getpip])

same = lambda x: (x, x)
dependencies = [
    same("arrow"),
    same("datetime"),
    same("distro"),
    same("forbiddenfruit"),
    same("iteration_utilities"),
    same("loguru"),
    same("platform"),
    same("pygit2"),
    same("requests"),
    same("toml"),
    ("typer", "typer[all]"),
]

for importName, packageName in dependencies:
    while True:
        try:
            globals()[importName] = __import__(importName)
            break
        except ModuleNotFoundError:
            subprocess.run(["pip", "install", packageName, "--user"])

# ------------------------------------------------------------------------------------------------|

# Add milliseconds to timedelta for logging
forbiddenfruit.curse(datetime.timedelta, "milliseconds", property(lambda self: f"{self.microseconds/1000:5.0f}"))

# Set up empty logger
loguru.logger.remove()
logger = loguru.logger.bind()

# Add stdout logging
logger.add(system.stdout, colorize=True, level="TRACE",
    format=f"[<green>{{elapsed.milliseconds}}ms</green>]─[<level>{{level:7}}</level>]<level> ▸ {{message}}</level>")

# self.* functions logging
for logType in ["info", "warning", "error", "debug", "trace", "success", "critical"]:
    globals()[logType] = getattr(logger, logType)

# ------------------------------------------------------------------------------------------------|

from iteration_utilities import deepflatten

# ['', True, "string", None, "--a"] -> [True, "string", "--a"]
truthyList = lambda stuff: [x for x in stuff if x]

# [[a, b], c, [d, e, f], [g, h]] -> [a, b, c, d, e, f, g, h]
flatten = lambda stuff: deepflatten(stuff, types=list)

# Flatten a list, remove falsy values, convert to strings
__shellify = lambda stuff: truthyList(map(str, flatten(stuff)))

# shell(["binary", "-m"], "arg1", "arg2", 3)
def shell(*a, output=False, echo=True, **k):
    command = __shellify(a)
    if echo: info(f"Running command {command}")
    if output:
        try:
            return subprocess.check_output(__shellify(a), **k).decode("utf-8")
        except subprocess.CalledProcessError as error:
            return error.output.decode("utf-8")
    else:
        subprocess.run(command, **k)

# # Utility functions

def binaryExists(binary) -> bool:
    return shutil.which(binary) is not None

def getBinary(binary) -> Path:
    if not binaryExists(binary):
        raise FileNotFoundError(f"Binary {binary} not found in PATH")
    return Path(shutil.which(binary))

@contextmanager
def download(url) -> Path:
    with tempfile.NamedTemporaryFile() as temp:
        temp.write(requests.get(url).content)
        yield Path(temp.name)

# ------------------------------------------------------------------------------------------------|

# "nightly" or "stable"
RUSTUP_TOOLCHAIN = "stable"

# Distros IDs: https://distro.readthedocs.io/en/latest/
LINUX_DISTRO = distro.id()
HOST_OS = platform.system().lower()

# Binaries shorthands
python = system.executable
sh = "sh" if (HOST_OS != "windows") else None
pip = [python, "-m", "pip"]
pacman = "pacman"
rustup = "rustup"
cargo = "cargo"
chmod = "chmod"
sudo = "sudo"
apt = "apt"
upx = "upx"

# ------------------------------------------------------------------------------------------------|

ABOUT = """
Broken Source Software Manager script

(c) 2023 Tremeschin, AGPLv3-only License.
"""

class Nebula:
    ProjectFeatures = {}
    FindProjectLowercase = {}

    def __init__(self) -> None:
        self.installRust()

    # Builds CLI commands and starts Typer
    def cli(self) -> None:
        self.typerApp = typer.Typer(help=ABOUT, no_args_is_help=True)
        self.typerApp.command()(self.date)
        self.typerApp.command()(self.release)
        self.typerApp.command()(self.requirements)
        self.typerApp.command()(self.hints)

        # Directories
        self.Root     = Path(__file__).absolute().parent
        self.Releases = self.Root/"Releases"
        self.Build    = self.Releases/"Build"

        # Cargo dictionary
        self.cargotoml = toml.loads((self.Root/"Cargo.toml").read_text())

        # Add Typer commands for all projects
        for project in self.cargotoml["bin"]:
            projectName = project["name"]

            # Don't add non existing projects (private repos)
            if not (self.Root/project["path"]).exists(): continue

            # List of required features specified in Cargo.tml
            if len(features := project.get("required-features", [])) > 0:
                features = [["--features", f] for f in features]

            Nebula.ProjectFeatures[projectName] = features
            Nebula.FindProjectLowercase[projectName.lower()] = projectName

            # This is a bit sophisticated, projectName should be kept after the callable
            # is created, so we have a method that creates a method with given string
            def runProjectTemplate(projectName, features):
                def runProject(ctx: typer.Context, release: bool=False):
                    release = ["--profile", "release"] if release else []
                    shell(cargo, "run", "--bin", projectName, features, release, "--", ctx.args)
                return runProject

            # Create Typer command
            self.typerApp.command(
                name=projectName.lower(),
                help=f"Project: {projectName}",

                # Catch extra (unknown to typer) arguments that are sent to Rust
                context_settings=dict(allow_extra_args=True, ignore_unknown_options=True),

                # Rust projects implement their own --help
                add_help_option=False,

            )(runProjectTemplate(projectName, features))

        # Execute the CLI
        self.typerApp()

    # Clone Protostar repository and submodules to current directory
    def gitCloneProtostar(self) -> None:

        # Not the most pretty progress bar but it does the job
        class GitCloneProgress(pygit2.RemoteCallbacks):
            def transfer_progress(self, stats):
                print(f"\r:: Progress: ({stats.received_bytes} bytes) ({stats.indexed_objects}/{stats.total_objects} objects)", end='', flush=True)
                if stats.indexed_objects == stats.total_objects: print("\r", end='')

        info("Cloning Protostar repository..")
        protostarRepo = pygit2.clone_repository("https://github.com/BrokenSource/Protostar", "Protostar", callbacks=GitCloneProgress())
        os.chdir("Protostar")

        # Attempt to init and clone public submodules
        for submodule in protostarRepo.listall_submodules():
            try:
                protostarRepo.init_submodules([submodule])
                info(f"Cloning submodule: [{submodule}]")
                protostarRepo.update_submodules([submodule], callbacks=GitCloneProgress())

                # Open submodule as a repository, checkout Master branch
                submoduleRepo = pygit2.Repository(f"Protostar/{submodule}")
                submoduleRepo.checkout(submoduleRepo.lookup_branch("Master"))

            # Ignore private submodules
            except Exception as error:
                if "authentication" in str(error): ...
                raise error

        info("Now type 'cd Protostar' and './nebula'")

    # Install Rust toolchain on macOS, Linux
    def installRust(self) -> None:

        # Install rustup for toolchains
        if not all([binaryExists(b) for b in ["rustup", "rustc", "cargo"]]):
            info(f"Installing Rustup default profile")

            # Get rustup link for each platform
            rustInstaller = dict(
                windows="https://static.rust-lang.org/rustup/dist/x86_64-pc-windows-gnu/rustup-init.exe",
                linux=  "https://sh.rustup.rs",
                macos=  "https://sh.rustup.rs"
            ).get(HOST_OS)

            # Download and install Rust
            with download(rustInstaller) as installer:
                shell(sh, installer, "--profile", "default", "-y")

        # Detect if default Rust toolchain installed is the one specificed in RUSTUP_TOOLCHAIN
        for line in shell(rustup, "toolchain", "list", output=True, echo=False).split("\n"):
            if ("no installed" in line) or (("default" in line) and (line.split("-")[0] != RUSTUP_TOOLCHAIN)):
                info(f"Defaulting Rust toolchain to [{RUSTUP_TOOLCHAIN}]")
                shell(rustup, "default", RUSTUP_TOOLCHAIN)

    # # Commands section

    def hints(self):
        """Let Nebula find Quality of Life stuff you can add to your system"""

        # "$ ./nebula" -> "$ nebula"
        if not "." in os.environ.get("PATH").split(os.pathsep):
            info(f"You can append '.' to $PATH env var so current directory binaries are found, no more typing './nebula' but simply 'nebula'. Add to your shell config: 'export PATH=$PATH:.'")

    # NOTE: Also returns date string
    def date(self) -> str:
        """Set current UTC dates on Cargo.toml"""
        date = arrow.utcnow().format("YYYY.M.D")

        # Find "version=" line and set it to "version={date}"", write back to file
        (self.Root/"Cargo.toml").write_text('\n'.join(
            [line if not line.startswith("version") else f'version = "{date}"'
            for line in (self.Root/"Cargo.toml").read_text().split("\n")]
        ))

        return date

    def release(self, project: str, platform: str, profile: str="ultra") -> None:
        """Compile and release a project (or 'all') to a target (or 'all') platform"""

        platformsConfiguration = {
            "linux-amd64":   ("x86_64-unknown-linux-gnu",  "",     ".bin"),
            # "linux-arm":     ("aarch64-unknown-linux-gnu", "",     ".bin"),
            "windows-amd64": ("x86_64-pc-windows-gnu",     ".exe", ".exe"),
            # "macos-amd64":   ("x86_64-apple-darwin",       "",     ".bin"),
            # "macos-arm":     ("aarch64-apple-darwin",      "",     ".bin"),
        }

        # Acronym for all available projects
        if project == "all":
            for project in Nebula.ProjectFeatures.keys():
                self.release(project, platform, profile)

        # Project CLI input may be lowercase
        project = Nebula.FindProjectLowercase.get(project, project)

        # Acronym for all available platforms
        if platform == "all":
            for platform in platformsConfiguration.keys():
                try: self.release(project, platform, profile)
                except FileNotFoundError:
                    error(f"Could not compile [{project}] for [{platform}]")
            return

        # # Target platform
        (targetTriple, compileSuffix, releaseSuffix) = platformsConfiguration[platform]

        # Update dates
        date = self.date()

        # Add target toolchain for Rust
        shell(rustup, "target", "add", targetTriple)

        # Build the binary
        shell(cargo, "build",
            "--bin", project,
            "--target", targetTriple,
            "--profile", profile,
            Nebula.ProjectFeatures[project]
        )

        # Post-compile binary namings and release name
        compiledBinary   = self.Build/targetTriple/profile/f"{project}{compileSuffix}"
        releaseBinary    = self.Releases/f"{project.lower()}-{platform}-{date}{releaseSuffix}"
        releaseBinaryUPX = releaseBinary.parent/(releaseBinary.stem + f"-upx{releaseSuffix}")

        # Default release and UPX
        shutil.copy(compiledBinary, releaseBinary)
        shell(upx, "-q", "-9", "--lzma", releaseBinary, "-o", releaseBinaryUPX)

    def requirements(self):
        """Install requirements based on platform"""

        # # Install Requirements depending on host platform
        if HOST_OS == "linux":
            if LINUX_DISTRO == "arch":
                self.shell(sudo, pacman, "-Syu", "base-devel gcc-fortran mingw-w64-toolchain upx".split())
                return

            self.warning(f"[{LINUX_DISTRO}] Linux Distro is not officially supported. Please fix or implement dependencies for your distro if it doesn't work.")

            if LINUX_DISTRO == "ubuntu":
                self.shell(sudo, apt, "update")
                self.shell(sudo, apt, "install", "build-essential mingw-w64 gcc upx".split())

        elif HOST_OS == "windows":
            raise NotImplementedError("Nebula releases on Windows not implemented")

        elif HOST_OS == "macos":
            raise NotImplementedError("Nebula releases on macOS not tested / implemented")

            # Install Homebrew
            with download("https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh") as installer:
                self.shell(bash, installer)

            # Install make dependencies
            self.shell(brew, "install", "mingw-w64", "upx")


# ------------------------------------------------------------------------------------------------|

if __name__ == "__main__":
    nebula = Nebula()

    # Running from a file or pipe?
    if system.stdin.isatty():
        nebula.cli()
    else:
        nebula.gitCloneProtostar()
